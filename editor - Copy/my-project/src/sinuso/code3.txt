import React, { useEffect, useState, useCallback, useMemo } from 'react';
import {
  BaseEdge,
  EdgeLabelRenderer,
  getSmoothStepPath,
  useReactFlow,
  type EdgeProps,
} from '@xyflow/react';
import type { UMLEdgeData } from '@/types/uml';

export type ImprovedUMLEdgeProps = EdgeProps & {
  data?: UMLEdgeData;
};

interface ControlPoint {
  id: string;
  x: number;
  y: number;
  type: 'control' | 'connection';
}

const ImprovedUMLEdge: React.FC<ImprovedUMLEdgeProps> = ({
  id,
  source,
  target,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  sourceHandleId,
  targetHandleId,
  data,
  selected,
}) => {
  const { getNodes, setEdges, getEdges } = useReactFlow();
  const [controlPoints, setControlPoints] = useState<ControlPoint[]>([]);
  const [isDragging, setIsDragging] = useState(false);
  const [dragPointId, setDragPointId] = useState<string | null>(null);
  const [isReconnecting, setIsReconnecting] = useState(false);
  const [reconnectionType, setReconnectionType] = useState<'source' | 'target' | null>(null);

  // Calcular puntos de control iniciales
  useEffect(() => {
    const midX = (sourceX + targetX) / 2;
    const midY = (sourceY + targetY) / 2;
    
    // Calcular puntos intermedios para ruta ortogonal
    const offsetX = Math.abs(targetX - sourceX) * 0.3;
    const offsetY = Math.abs(targetY - sourceY) * 0.3;
    
    setControlPoints([
      {
        id: `${id}-source-connection`,
        x: sourceX,
        y: sourceY,
        type: 'connection'
      },
      {
        id: `${id}-control-1`,
        x: sourceX + (sourceX < targetX ? offsetX : -offsetX),
        y: sourceY,
        type: 'control'
      },
      {
        id: `${id}-control-center`,
        x: midX,
        y: midY,
        type: 'control'
      },
      {
        id: `${id}-control-2`,
        x: targetX - (sourceX < targetX ? offsetX : -offsetX),
        y: targetY,
        type: 'control'
      },
      {
        id: `${id}-target-connection`,
        x: targetX,
        y: targetY,
        type: 'connection'
      }
    ]);
  }, [sourceX, sourceY, targetX, targetY, id]);

  // Crear path personalizado usando puntos de control
  const customPath = useMemo(() => {
    if (controlPoints.length < 3) {
      return getSmoothStepPath({
        sourceX,
        sourceY,
        sourcePosition,
        targetX,
        targetY,
        targetPosition,
        borderRadius: 0,
        offset: 20,
      });
    }

    // Construir path ortogonal usando puntos de control
    const pathCommands: string[] = [];
    pathCommands.push(`M ${controlPoints[0].x},${controlPoints[0].y}`);
    
    for (let i = 1; i < controlPoints.length; i++) {
      const current = controlPoints[i];
      const previous = controlPoints[i - 1];
      
      // Crear segmentos ortogonales
      if (Math.abs(current.x - previous.x) > Math.abs(current.y - previous.y)) {
        // Movimiento principalmente horizontal
        if (current.y !== previous.y) {
          pathCommands.push(`L ${previous.x},${current.y}`);
        }
        pathCommands.push(`L ${current.x},${current.y}`);
      } else {
        // Movimiento principalmente vertical
        if (current.x !== previous.x) {
          pathCommands.push(`L ${current.x},${previous.y}`);
        }
        pathCommands.push(`L ${current.x},${current.y}`);
      }
    }
    
    const pathData = pathCommands.join(' ');
    const centerPoint = controlPoints[Math.floor(controlPoints.length / 2)];
    
    return [pathData, centerPoint.x, centerPoint.y] as const;
  }, [controlPoints, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition]);

  const [edgePath, labelX, labelY] = customPath;

  // Manejar inicio de arrastre
  const handleMouseDown = useCallback((pointId: string, event: React.MouseEvent) => {
    event.stopPropagation();
    event.preventDefault();
    
    const point = controlPoints.find(p => p.id === pointId);
    if (!point) return;
    
    setIsDragging(true);
    setDragPointId(pointId);
    
    // Si es un punto de conexión, habilitar reconexión
    if (point.type === 'connection') {
      setIsReconnecting(true);
      setReconnectionType(pointId.includes('source') ? 'source' : 'target');
    }
    
    const startX = event.clientX;
    const startY = event.clientY;
    const startPointX = point.x;
    const startPointY = point.y;
    
    const handleMouseMove = (e: MouseEvent) => {
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      const newX = startPointX + deltaX;
      const newY = startPointY + deltaY;
      
      if (point.type === 'connection') {
        // Para puntos de conexión, buscar nodos cercanos
        const nodes = getNodes();
        const nearNode = findNearestNode(nodes, newX, newY, point.type === 'connection' ? (pointId.includes('source') ? source : target) : null);
        
        if (nearNode) {
          // Mostrar preview de conexión
          document.body.style.cursor = 'copy';
        } else {
          document.body.style.cursor = 'not-allowed';
        }
      }
      
      setControlPoints(prev => 
        prev.map(cp => 
          cp.id === pointId 
            ? { ...cp, x: newX, y: newY }
            : cp
        )
      );
    };
    
    const handleMouseUp = (e: MouseEvent) => {
      if (isReconnecting && point.type === 'connection') {
        const nodes = getNodes();
        const newTargetNode = findNearestNode(nodes, point.x, point.y, pointId.includes('source') ? source : target);
        
        if (newTargetNode && newTargetNode.id !== (pointId.includes('source') ? source : target)) {
          // Actualizar la conexión
          const edges = getEdges();
          const updatedEdges = edges.map(edge => {
            if (edge.id === id) {
              return {
                ...edge,
                [reconnectionType === 'source' ? 'source' : 'target']: newTargetNode.id,
                [reconnectionType === 'source' ? 'sourceHandle' : 'targetHandle']: findBestHandle(newTargetNode, point.x, point.y)
              };
            }
            return edge;
          });
          setEdges(updatedEdges);
        }
      }
      
      setIsDragging(false);
      setDragPointId(null);
      setIsReconnecting(false);
      setReconnectionType(null);
      document.body.style.cursor = '';
      
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }, [controlPoints, getNodes, getEdges, setEdges, id, source, target, isReconnecting]);

  // Encontrar nodo más cercano para reconexión
  const findNearestNode = (nodes: any[], x: number, y: number, excludeNodeId?: string) => {
    const SNAP_DISTANCE = 100;
    let nearestNode = null;
    let minDistance = SNAP_DISTANCE;
    
    nodes.forEach(node => {
      if (node.id === excludeNodeId) return;
      
      const nodeX = node.position.x + (node.width || 200) / 2;
      const nodeY = node.position.y + (node.height || 150) / 2;
      const distance = Math.sqrt(Math.pow(x - nodeX, 2) + Math.pow(y - nodeY, 2));
      
      if (distance < minDistance) {
        minDistance = distance;
        nearestNode = node;
      }
    });
    
    return nearestNode;
  };

  // Encontrar el mejor handle para la conexión
  const findBestHandle = (node: any, x: number, y: number) => {
    const nodeX = node.position.x + (node.width || 200) / 2;
    const nodeY = node.position.y + (node.height || 150) / 2;
    
    // Calcular qué lado del nodo está más cerca
    const deltaX = x - nodeX;
    const deltaY = y - nodeY;
    
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      return deltaX > 0 ? 'right-center' : 'left-center';
    } else {
      return deltaY > 0 ? 'bottom-center' : 'top-center';
    }
  };

  // Añadir nuevo punto de control
  const handleEdgeDoubleClick = useCallback((event: React.MouseEvent) => {
    if (!selected) return;
    
    event.stopPropagation();
    const rect = (event.target as Element).closest('.react-flow')?.getBoundingClientRect();
    if (!rect) return;
    
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    const newPoint: ControlPoint = {
      id: `${id}-custom-${Date.now()}`,
      x,
      y,
      type: 'control'
    };
    
    // Insertar en posición apropiada
    const centerIndex = Math.floor(controlPoints.length / 2);
    setControlPoints(prev => [
      ...prev.slice(0, centerIndex),
      newPoint,
      ...prev.slice(centerIndex)
    ]);
  }, [selected, id, controlPoints]);

  const getEdgeStyle = () => {
    const relationType = data?.relationType || 'association';
    const isDark = document.documentElement.classList.contains('dark');
    
    const baseStyle = {
      strokeWidth: 2,
      stroke: selected 
        ? '#3b82f6' 
        : isDark ? '#374151' : '#000000',
    };
    
    switch (relationType) {
      case 'inheritance':
        return { 
          ...baseStyle, 
          stroke: selected ? '#3b82f6' : '#000000'
        };
      case 'composition':
        return { 
          ...baseStyle, 
          stroke: selected ? '#3b82f6' : '#000000'
        };
      case 'aggregation':
        return { 
          ...baseStyle, 
          stroke: selected ? '#3b82f6' : '#000000'
        };
      case 'many-to-many':
        return { 
          ...baseStyle, 
          strokeDasharray: '5,5', 
          stroke: selected ? '#3b82f6' : '#9333ea'
        };
      case 'association':
      default:
        return { 
          ...baseStyle, 
          stroke: selected ? '#3b82f6' : '#000000'
        };
    }
  };

  const getMarkerEnd = () => {
    const relationType = data?.relationType || 'association';
    
    switch (relationType) {
      case 'inheritance':
        return 'url(#inheritance-marker)';
      case 'composition':
        return 'url(#composition-marker)';
      case 'aggregation':
        return 'url(#aggregation-marker)';
      case 'association':
      case 'many-to-many':
      default:
        return 'url(#association-marker)';
    }
  };

  return (
    <>
      <BaseEdge
        path={edgePath}
        markerEnd={getMarkerEnd()}
        style={getEdgeStyle()}
        onDoubleClick={handleEdgeDoubleClick}
      />
      
      <EdgeLabelRenderer>
        {/* Puntos de control - solo mostrar cuando está seleccionada */}
        {selected && controlPoints.map(point => (
          <div
            key={point.id}
            style={{
              position: 'absolute',
              transform: `translate(-50%, -50%) translate(${point.x}px, ${point.y}px)`,
              width: point.type === 'connection' ? '14px' : '10px',
              height: point.type === 'connection' ? '14px' : '10px',
              backgroundColor: point.type === 'connection' 
                ? (isReconnecting && dragPointId === point.id ? '#ef4444' : '#dc2626') 
                : '#3b82f6',
              border: '2px solid white',
              borderRadius: '50%',
              cursor: isDragging ? 'grabbing' : 'grab',
              zIndex: 1000,
              pointerEvents: 'all',
              boxShadow: '0 2px 4px rgba(0,0,0,0.3)',
              transition: isDragging ? 'none' : 'all 0.2s ease',
            }}
            className={`${isDragging && dragPointId === point.id ? 'scale-125' : 'hover:scale-110'}`}
            onMouseDown={(e) => handleMouseDown(point.id, e)}
            title={
              point.type === 'connection' 
                ? 'Arrastrar para reconectar a otra clase' 
                : 'Arrastrar para cambiar forma'
            }
          />
        ))}
        
        {/* Source multiplicity */}
        {data?.sourceMultiplicity && (
          <div
            style={{
              position: 'absolute',
              transform: `translate(-50%, -50%) translate(${sourceX + 20}px,${sourceY - 20}px)`,
              fontSize: 12,
              pointerEvents: 'all',
              padding: '2px 4px',
              borderRadius: '2px',
            }}
            className="nodrag nopan bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 text-gray-800 dark:text-gray-200"
          >
            {data.sourceMultiplicity}
          </div>
        )}
        
        {/* Target multiplicity */}
        {data?.targetMultiplicity && (
          <div
            style={{
              position: 'absolute',
              transform: `translate(-50%, -50%) translate(${targetX - 20}px,${targetY - 20}px)`,
              fontSize: 12,
              pointerEvents: 'all',
              padding: '2px 4px',
              borderRadius: '2px',
            }}
            className="nodrag nopan bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 text-gray-800 dark:text-gray-200"
          >
            {data.targetMultiplicity}
          </div>
        )}
        
        {/* Edge label */}
        {data?.label && (
          <div
            style={{
              position: 'absolute',
              transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
              fontSize: 12,
              pointerEvents: 'all',
              padding: '2px 6px',
              borderRadius: '3px',
            }}
            className="nodrag nopan bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 text-gray-800 dark:text-gray-200"
          >
            {data.label}
          </div>
        )}

        {/* Instrucciones de uso */}
        {selected && (
          <div
            style={{
              position: 'absolute',
              transform: `translate(-50%, -50%) translate(${labelX}px,${labelY + 50}px)`,
              fontSize: 10,
              pointerEvents: 'none',
              padding: '4px 8px',
              borderRadius: '4px',
              opacity: 0.8,
            }}
            className="bg-gray-800 text-white dark:bg-gray-200 dark:text-gray-800"
          >
            Puntos rojos: arrastrar para reconectar • Puntos azules: cambiar forma • Doble clic: añadir punto
          </div>
        )}
      </EdgeLabelRenderer>
    </>
  );
};

export default ImprovedUMLEdge;